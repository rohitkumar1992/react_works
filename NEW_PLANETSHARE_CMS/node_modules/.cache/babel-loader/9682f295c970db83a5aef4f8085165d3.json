{"ast":null,"code":"'use strict';\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\n\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style; // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (typeof window !== 'undefined') {\n  detectEvents();\n} // We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nmodule.exports = {\n  addEndEventListener: function (node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n\n    endEvents.forEach(function (endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n  removeEndEventListener: function (node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n\n    endEvents.forEach(function (endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};","map":{"version":3,"sources":["/var/www/html/REACT_WORK/NEW_PLANETSHARE_CMS/node_modules/domkit/transitionEvents.js"],"names":["EVENT_NAME_MAP","transitionend","animationend","endEvents","detectEvents","testEl","document","createElement","style","window","animation","transition","baseEventName","baseEvents","styleName","push","addEventListener","node","eventName","eventListener","removeEventListener","module","exports","addEndEventListener","length","setTimeout","forEach","endEvent","removeEndEventListener"],"mappings":"AAAA;AAEA;;;;;;AAKA,IAAIA,cAAc,GAAG;AACnBC,EAAAA,aAAa,EAAE;AACb,kBAAc,eADD;AAEb,wBAAoB,qBAFP;AAGb,qBAAiB,kBAHJ;AAIb,mBAAe,gBAJF;AAKb,oBAAgB;AALH,GADI;AASnBC,EAAAA,YAAY,EAAE;AACZ,iBAAa,cADD;AAEZ,uBAAmB,oBAFP;AAGZ,oBAAgB,iBAHJ;AAIZ,kBAAc,eAJF;AAKZ,mBAAe;AALH;AATK,CAArB;AAkBA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,SAASC,YAAT,GAAwB;AACtB,MAAIC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAb;AACA,MAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB,CAFsB,CAItB;AACA;AACA;AACA;AACA;;AACA,MAAI,EAAE,oBAAoBC,MAAtB,CAAJ,EAAmC;AACjC,WAAOT,cAAc,CAACE,YAAf,CAA4BQ,SAAnC;AACD;;AAED,MAAI,EAAE,qBAAqBD,MAAvB,CAAJ,EAAoC;AAClC,WAAOT,cAAc,CAACC,aAAf,CAA6BU,UAApC;AACD;;AAED,OAAK,IAAIC,aAAT,IAA0BZ,cAA1B,EAA0C;AACxC,QAAIa,UAAU,GAAGb,cAAc,CAACY,aAAD,CAA/B;;AACA,SAAK,IAAIE,SAAT,IAAsBD,UAAtB,EAAkC;AAChC,UAAIC,SAAS,IAAIN,KAAjB,EAAwB;AACtBL,QAAAA,SAAS,CAACY,IAAV,CAAeF,UAAU,CAACC,SAAD,CAAzB;AACA;AACD;AACF;AACF;AACF;;AAED,IAAI,OAAOL,MAAP,KAAkB,WAAtB,EAAmC;AACjCL,EAAAA,YAAY;AACb,C,CAGD;AACA;AACA;AACA;;;AAEA,SAASY,gBAAT,CAA0BC,IAA1B,EAAgCC,SAAhC,EAA2CC,aAA3C,EAA0D;AACxDF,EAAAA,IAAI,CAACD,gBAAL,CAAsBE,SAAtB,EAAiCC,aAAjC,EAAgD,KAAhD;AACD;;AAED,SAASC,mBAAT,CAA6BH,IAA7B,EAAmCC,SAAnC,EAA8CC,aAA9C,EAA6D;AAC3DF,EAAAA,IAAI,CAACG,mBAAL,CAAyBF,SAAzB,EAAoCC,aAApC,EAAmD,KAAnD;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,mBAAmB,EAAE,UAASN,IAAT,EAAeE,aAAf,EAA8B;AACjD,QAAIhB,SAAS,CAACqB,MAAV,KAAqB,CAAzB,EAA4B;AAC1B;AACA;AACAf,MAAAA,MAAM,CAACgB,UAAP,CAAkBN,aAAlB,EAAiC,CAAjC;AACA;AACD;;AACDhB,IAAAA,SAAS,CAACuB,OAAV,CAAkB,UAASC,QAAT,EAAmB;AACnCX,MAAAA,gBAAgB,CAACC,IAAD,EAAOU,QAAP,EAAiBR,aAAjB,CAAhB;AACD,KAFD;AAGD,GAXc;AAafS,EAAAA,sBAAsB,EAAE,UAASX,IAAT,EAAeE,aAAf,EAA8B;AACpD,QAAIhB,SAAS,CAACqB,MAAV,KAAqB,CAAzB,EAA4B;AAC1B;AACD;;AACDrB,IAAAA,SAAS,CAACuB,OAAV,CAAkB,UAASC,QAAT,EAAmB;AACnCP,MAAAA,mBAAmB,CAACH,IAAD,EAAOU,QAAP,EAAiBR,aAAjB,CAAnB;AACD,KAFD;AAGD;AApBc,CAAjB","sourcesContent":["'use strict';\n\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (typeof window !== 'undefined') {\n  detectEvents();\n}\n\n\n// We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nmodule.exports = {\n  addEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n  removeEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"script"}